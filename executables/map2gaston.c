#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "../graph.h"
#include "../loading.h"
#include "../cs_Tree.h"
#include "../searchTree.h"


/**
 * Print --help message
 */
void printHelp() {
	printf("Maps a output file of lwm to the expected input of gaston graph mining\n");
	printf("Either give filename as an argument or pipe something in\n");
}


void map2Gaston(FILE* data, struct GraphPool* gp, struct ShallowGraphPool* sgp) {
	int bufferSize = 100;
	int graphNumber;
	struct ShallowGraph* patterns;
	char** labels = aids99VertexLabelArray();

	while ((patterns = streamReadPatterns(data, bufferSize, &graphNumber, sgp))) {
		struct ShallowGraph* pattern;
		struct Graph* spanningTree = NULL;
		int offset = 0;

		fprintf(stdout, "t # %i\n", graphNumber);
		for (pattern=patterns; pattern!=NULL; pattern=pattern->next) {
			int v;
			/* convert streamed spanning tree string to graph */
			if (spanningTree != NULL) {
				for (v=0; v<spanningTree->n; ++v) {
					dumpVertexListRecursively(gp->listPool, spanningTree->vertices[v]->neighborhood);
					spanningTree->vertices[v]->neighborhood = NULL;
				}
				canonicalString2ExistingGraph(pattern, spanningTree, gp);
			} else {
				spanningTree = treeCanonicalString2Graph(pattern, gp);
			}

			/* print vertices */
			for (v=0; v<spanningTree->n; ++v) {
				int i;
				for (i=0; i<64; ++i) {
					if (strcmp(spanningTree->vertices[v]->label, labels[i]) == 0) {
						fprintf(stdout, "v %i %i\n", v + offset, i);
						break; /* continue with next vertex */
					}
				}
			}
			/* and increment the offset */
			offset += spanningTree->n;
		}
		offset = 0;
		for (pattern=patterns; pattern!=NULL; pattern=pattern->next) {
			int v;
			/* convert streamed spanning tree string to graph */
			if (spanningTree != NULL) {
				for (v=0; v<spanningTree->n; ++v) {
					dumpVertexListRecursively(gp->listPool, spanningTree->vertices[v]->neighborhood);
					spanningTree->vertices[v]->neighborhood = NULL;
				}
				canonicalString2ExistingGraph(pattern, spanningTree, gp);
			} else {
				spanningTree = treeCanonicalString2Graph(pattern, gp);
			}

			/* print edges */
			for (v=0; v<spanningTree->n; ++v) {
				struct VertexList* e;
				for (e=spanningTree->vertices[v]->neighborhood; e!=NULL; e=e->next) {
					if (e->endPoint->number > v) {
						fprintf(stdout, "e %i %i %s\n", v + offset, e->endPoint->number + offset, e->label);
					}
				}
			}
			/* and increment the offset */
			offset += spanningTree->n;
		}

		dumpGraph(gp, spanningTree);
		dumpShallowGraphCycle(sgp, patterns);
	}
	free(labels);
}


/**
 Main method of the TreePatternKernel levelwise pattern generation algorithm.
 It will use a database of spanning trees generated by the preprocessing 
 algorithm accompanying it.
 */
int main(int argc, char** argv) {
	if ((argc > 2) || (strcmp(argv[1], "--help") == 0) || (strcmp(argv[1], "-h") == 0)) {
		printHelp();
		return EXIT_FAILURE;
	} else {

		/* create object pools */
		struct ListPool *lp = createListPool(1);
		struct VertexPool *vp = createVertexPool(1);
		struct ShallowGraphPool *sgp = createShallowGraphPool(1, lp);
		struct GraphPool *gp = createGraphPool(1, vp, lp);

		FILE* data;

		if (argc == 1) {
			map2Gaston(stdin, gp, sgp);
		} else {
			data = fopen(argv[1], "r");
			if (data == NULL) {
				fprintf(stderr, "Could not open file provided by argument.\n");
				return EXIT_FAILURE;
			}
			map2Gaston(data, gp, sgp);
			fclose(data);
		}
		
		/* garbage collection */
		freeGraphPool(gp);
		freeShallowGraphPool(sgp);
		freeListPool(lp);
		freeVertexPool(vp);

		return EXIT_SUCCESS;
	}
}
