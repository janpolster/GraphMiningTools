#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <limits.h>

#include "graph.h"
#include "canonicalString.h"
#include "searchTree.h"
#include "loading.h"
#include "listSpanningTrees.h"
#include "upperBoundsForSpanningTrees.h"
#include "subtreeIsomorphism.h"
#include "graphPrinting.h"
#include "treeCenter.h"
#include "connectedComponents.h"
#include "levelwiseMain.h" 
#include "levelwiseMining.h"
/* #include "opk.h" */

char DEBUG_INFO = 1;


/**
 * Print --help message
 */
void printHelp() {
	printf("This is a Levelwise Algorithm for TreePatterns\n");
	printf("implemented by Pascal Welke 2013\n\n\n");
	printf("usage: lwm F [parameterList]\n\n");
	printf("    without parameters: display this help screen\n\n");
	printf("    F: (required) use F as graph database\n\n");
	printf("    -output O: write output to stdout\n");

	printf("    -limit N: process the first N graphs in F\n\n");
	printf("    -h | --help: display this help\n\n");
}


/**
 Main method of the TreePatternKernel levelwise pattern generation algorithm.
 It will use a database of spanning trees generated by the preprocessing 
 algorithm accompanying it.
 */
int main(int argc, char** argv) {
	if ((argc < 2) || (strcmp(argv[1], "--help") == 0) || (strcmp(argv[1], "-h") == 0)) {
		printHelp();
		return EXIT_FAILURE;
	} else {

		/* create object pools */
		struct ListPool *lp = createListPool(1);
		struct VertexPool *vp = createVertexPool(1);
		struct ShallowGraphPool *sgp = createShallowGraphPool(1, lp);
		struct GraphPool *gp = createGraphPool(1, vp, lp);

		/* user input handling variables */
		char outputOption = 0;
		int param;

		/* graph delimiter */
		int maxGraphs = -1;

		/* user input handling */
		for (param=2; param<argc; param+=2) {
			if ((strcmp(argv[param], "--help") == 0) || (strcmp(argv[param], "-h") == 0)) {
				printHelp();
				return EXIT_SUCCESS;
			}
			if (strcmp(argv[param], "-limit") == 0) {
				sscanf(argv[param+1], "%i", &maxGraphs);
			}
			if (strcmp(argv[param], "-output") == 0) {
				outputOption = argv[param+1][0];
			}
		}

		if (outputOption == 0) {
			outputOption = 'a';
		}

		// init params
		int threshold = 1;
		int maxPatternSize = 1;
		char* featureFileName = "results/features.txt";
		char* countFileName = "results/counts.txt";
		char* inputFileName = "results/2013-07-23_spanningTreePatterns.txt";
		char* patternFileName = "results/patterns.txt";
		int minGraph = 0;
		int maxGraph = 1;

		/* internal init */
		FILE* featureFile = fopen(featureFileName, "w");
		FILE* countFile = fopen(countFileName, "w");
		FILE* patternFile = fopen(patternFileName, "w");

		struct Vertex* frequentPatterns;

		struct Vertex* frequentVertices = getVertex(vp);
		struct Vertex* frequentEdges = getVertex(vp);
		struct ShallowGraph* extensionEdges;
		int patternSize;

		/* find frequent single vertices and frequent edges */
		getVertexAndEdgeHistograms(inputFileName, minGraph, maxGraph, frequentVertices, frequentEdges, gp, sgp);
		fprintf(stderr, "loading done\n");
		filterSearchTree(frequentVertices, threshold, frequentVertices, gp);
		filterSearchTree(frequentEdges, threshold, frequentEdges, gp);
		fprintf(stderr, "filtering done\n");

		// debug
		fprintf(stderr, "vertices:\n");
		printStringsInSearchTree(frequentVertices, stderr, sgp); 
		//fprintf(stderr, "frequentVertices d %i v %i n %i\n", frequentVertices->d, frequentVertices->visited, frequentVertices->number);
		fprintf(stderr, "edges:\n");
		printStringsInSearchTree(frequentEdges, stderr, sgp); 
		//fprintf(stderr, "frequentEdges d %i v %i n %i\n", frequentEdges->d, frequentEdges->visited, frequentEdges->number);

		/* convert frequentEdges to ShallowGraph */
		extensionEdges = edgeSearchTree2ShallowGraph(frequentEdges, gp, sgp);	

		for (frequentPatterns = frequentEdges, patternSize = 0; (frequentPatterns->d > 0) && (patternSize < maxPatternSize); ++patternSize) {
			int i;
			struct ShallowGraph* prefix = getShallowGraph(sgp);

			struct Vertex* candidateSet = generateCandidateSet(frequentPatterns, extensionEdges, gp, sgp);
			struct Vertex** pointers = malloc(candidateSet->d * sizeof(struct Vertex*));
			struct Graph** refinements = malloc(candidateSet->d * sizeof(struct Graph*));

			// debug
			fprintf(stderr, "candidates size %i:\n", patternSize);
			printStringsInSearchTree(candidateSet, stderr, sgp); 

			makeGraphsAndPointers(candidateSet, candidateSet, refinements, pointers, 0, prefix, gp, sgp);

			// debug
			fprintf(stderr, "makeGraphsAndPointers:\n");
			printStringsInSearchTree(candidateSet, stderr, sgp); 

			scanDB(inputFileName, candidateSet, refinements, pointers, candidateSet->d, minGraph, maxGraph, gp, sgp);

			//	computeFrequencies(candidateSet, inputFileName, minGraph, maxGraph);
			// /* threshold + 1 as candidateSet contains each candidate once, already */
			//filterSearchTree(candidateSet, threshold + 1, candidateSet, gp);
			//resetToUnique(candidateSet);

			// debug
			fprintf(stderr, "counts\n");
			printStringsInSearchTree(candidateSet, stderr, sgp); 

			dumpSearchTree(gp, frequentPatterns);
			dumpShallowGraph(sgp, prefix);
			free(pointers);
			for (i=0; i<candidateSet->d; ++i) {
				dumpGraph(gp, refinements[i]);
			}
			free(refinements);
			frequentPatterns = candidateSet;
		}

		// debug garbage collection
		freeFrequentEdgeShallowGraph(gp, sgp, extensionEdges);
		dumpSearchTree(gp, frequentVertices);
		dumpSearchTree(gp, frequentPatterns);

		/* garbage collection */
		fclose(featureFile);
		fclose(countFile);
		fclose(patternFile);

		freeGraphPool(gp);
		freeShallowGraphPool(sgp);
		freeListPool(lp);
		freeVertexPool(vp);

		return EXIT_SUCCESS;
	}
}
