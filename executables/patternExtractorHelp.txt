This program returns some extracted features for each graph in a db.

Usage: ./gpe [OPTIONS] [FILE]

If no FILE argument is given or FILE is - the program reads from stdin.
It always prints to stdout.


Options:

-m METHOD: Specify the features this method should output
    
    triangles (default):   Compute a set of fingerprints that is based on the
	                       triangles in a graph that contain at least two edges
	                       that are present. For sparse graphs, this is much
	                       faster than brute force enumeration of all induced
	                       subgraphs of size 3.
    
    triples:               Compute a set of fingerprints based on the set of all
                           induced subgraphs of size 3.
    
    treePatterns:          Given a set of tree patterns (specified via -f or -c), 
                           return the set of tree patterns that match the graph 
                           (i.e. those that are subgraph isomorphic to the graph). 
                           This method only supports forest databases and tree 
                           patterns.
    
    treePatternsFast:      Given a set of tree patterns (specified via -f or -c), 
                           return the set of tree patterns that match the graph 
                           (i.e. those that are subgraph isomorphic to the graph). 
                           This method only supports forest databases and tree 
                           patterns. This version assumes that the set of patterns 
                           is closed under taking subgraphs and uses apriori-like
                           pruning for each graph to speed up computations.
                           
    localEasyPatternsFast: Given a set of tree patterns (specified via -f or -c), 
                           return a subset of the tree patterns that match the graph 
                           (i.e. those that are subgraph isomorphic to the graph). 
                           This method supports forest and general graph databases 
                           but only tree patterns. 
                           For this it uses the localEasySampling embedding opera-
                           tor. The number of sampled local trees per root can be
                           specified via the -i parameter and must be an int >= 1.
                           This version assumes that the set of patterns is closed 
                           under taking subgraphs and uses apriori-like pruning
                           for each graph to speed up computations. The spanning 
                           trees for each graph are sampled once before the traver-
                           sal of the pattern poset and not resampled for different
                           patterns.
                           
    localEasyPatternsResampling:  Given a set of tree pattenrs (specified via -f 
                                  or -c), return a subset of the tree patterns that 
                                  match the graph (i.e. those that are subgraph 
                                  isomorphic to the graph). This method supports 
                                  forest and general graph databases but only tree 
                                  patterns. 
                                  It uses the localEasySampling embedding opera-
                                  tor. The number of sampled local trees per root 
                                  can be specified via the -i parameter and must 
                                  be an int >= 1. This version tests each pattern 
                                  independently of any apriori pruning of the 
                                  pattern space and resamples spanning trees for
                                  each pattern.
    
    minHash:               Compute a min-hash array of size k (specified via -k)
                           for the feature set computed by treePatternsFast. It 
                           uses the ideas described in our paper (citation needed) 
                           to do this fast. The current version only works for 
                           tree patterns and  forest databases.
    
    minHashAbs:            Min-hashing as above with the absolute importance embedding 
                           operator. Importance threshold needs to be specified via
                           -i (default 5). The current version only works for 
                           tree patterns and  forest databases.
    
    minHashRel:            Min-hashing as above with the relative importance embedding
                           operator. Importance threshold needs to be specified via
                           -i (default 0.5). The current version only works for 
                           tree patterns and  forest databases. 
    
    minHashAndOr:          Same as above with embedding operator being a funky gap
                           amplificator. Only works for exactly 16 sampled trees per
                           graph. Hat tip to the input agnostic algorithm guy that
                           cries in vain. 


-k INT:                    Specify the number of permutations used by the minHash* 
                           methods.
                           
                           
-i DOUBLE or INT:          Specify the importance threshold used by the various 
                           methods that respect importance. For absolute importance,
                           the value should be a positive integer (default 5), for
                           relative importance, the value should be larger than zero
                           and not larger than one (default 0.5).
                           
                           
-c FILENAME:               Load patterns from file in canonical string format.


-f FILENAME:               Load patterns from file in AIDS99 format.


-r INT:                    Init random number generator (e.g. needed by 
                           localEasyPatternsFast) with given seed. Defaults to current
                           system time.
                           

To run the spanning tree sampling algorithms described in our paper, first transform
your graph database of choice to a forest database using the program ts. Then mine some
frequent subtrees using lwg on that forest db. With the patterns from the latter and new 
(or old) forests from the former, you can now get feature representations and min-hashes 
and whatnot to have jolly fun. 

